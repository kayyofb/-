# Игра UNO написанная с помощью Kivy framework.

import random
from functools import partial

from kivy.app import App
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.gridlayout import GridLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.popup import Popup
from kivy.uix.scrollview import ScrollView
from kivy.clock import Clock

COLOURS = ['red', 'yellow', 'green', 'blue']
NUMBER_VALUES = [str(n) for n in range(10)]
SPECIAL_VALUES = ['skip', 'reverse', 'draw_two']
WILD_VALUES = ['wild', 'wild_draw_four']


def create_deck():
    deck = []
    for colour in COLOURS:
        deck.append({'colour': colour, 'value': '0'})
        for val in NUMBER_VALUES[1:] + SPECIAL_VALUES:
            deck.append({'colour': colour, 'value': val})
            deck.append({'colour': colour, 'value': val})
    for _ in range(4):
        deck.append({'colour': 'wild', 'value': 'wild'})
        deck.append({'colour': 'wild', 'value': 'wild_draw_four'})
    return deck


def shuffle_deck(deck):
    random.shuffle(deck)


def draw_card(state, player_idx):
    deck = state['deck']
    discard = state['discard']
    if not deck:
        top = discard.pop()
        new_deck = discard
        shuffle_deck(new_deck)
        state['deck'] = new_deck
        state['discard'] = [top]
        deck = state['deck']
    card = deck.pop()
    state['hands'][player_idx].append(card)
    return card


def draw_multiple(state, player_idx, count):
    for _ in range(count):
        draw_card(state, player_idx)


def initial_setup(num_players):
    deck = create_deck()
    shuffle_deck(deck)
    hands = [[] for _ in range(num_players)]
    for _ in range(7):
        for h in hands:
            h.append(deck.pop())
    discard = []
    current_colour = None
    current_value = None
    while deck:
        card = deck.pop()
        if card['colour'] != 'wild' and card['value'] not in SPECIAL_VALUES:
            discard.append(card)
            current_colour = card['colour']
            current_value = card['value']
            break
        deck.insert(0, card)
    if not discard:
        card = deck.pop()
        discard.append(card)
        current_colour = card['colour'] if card['colour'] != 'wild' else COLOURS[0]
        current_value = card['value']
    state = {
        'deck': deck,
        'discard': discard,
        'hands': hands,
        'turn': 0,
        'direction': 1,
        'current_colour': current_colour,
        'current_value': current_value,
        'num_players': num_players,
    }
    return state


def can_play(card, current_colour, current_value):
    if card['colour'] == 'wild':
        return True
    return card['colour'] == current_colour or card['value'] == current_value


def next_turn_index(state, offset=1):
    num = state['num_players']
    current = state['turn']
    direction = state['direction']
    return (current + direction * offset) % num


def advance_turn(state, offset=1):
    state['turn'] = next_turn_index(state, offset)


def apply_played_card(card, state):
    if card['colour'] != 'wild':
        state['current_colour'] = card['colour']
    state['current_value'] = card['value']
    state['discard'].append(card)
    draw_count = 0
    turn_offset = 1
    if card['value'] == 'skip':
        turn_offset = 2
    elif card['value'] == 'reverse':
        state['direction'] *= -1
        if state['num_players'] == 2:
            turn_offset = 2
        else:
            turn_offset = 1
    elif card['value'] == 'draw_two':
        draw_count = 2
        turn_offset = 2
    elif card['value'] == 'wild_draw_four':
        draw_count = 4
        turn_offset = 2
    elif card['value'] == 'wild':
        turn_offset = 1
    return draw_count, turn_offset


def check_winner(state):
    for idx, hand in enumerate(state['hands']):
        if not hand:
            return idx
    return None

# Пользовательский интерфейс Kivy

class StartScreen(Screen):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        layout = BoxLayout(orientation='vertical', spacing=10, padding=20)
        self.add_widget(layout)
        title = Label(text='UNO', font_size='40sp', size_hint=(1, 0.3))
        layout.add_widget(title)
        btn_friend = Button(text='Play with Friend', size_hint=(1, 0.3))
        btn_computer = Button(text='Play against Computer', size_hint=(1, 0.3))
        layout.add_widget(btn_friend)
        layout.add_widget(btn_computer)
        btn_friend.bind(on_release=lambda _: self.start_game(False))
        btn_computer.bind(on_release=lambda _: self.start_game(True))

    def start_game(self, vs_computer):
        game_screen = GameScreen(name='game', vs_computer=vs_computer)
        self.manager.add_widget(game_screen)
        self.manager.current = 'game'


class GameScreen(Screen):

    def __init__(self, vs_computer=True, **kwargs):
        super().__init__(**kwargs)
        self.vs_computer = vs_computer
        self.state = initial_setup(2)
        self.top_hand_container = None
        self.bottom_hand_container = None
        self.discard_btn = None
        self.deck_btn = None
        self.turn_label = None
        self.build_ui()
        Clock.schedule_once(lambda dt: self.post_build_init(), 0)

    def post_build_init(self):
        self.update_ui()

    def build_ui(self):
        root = BoxLayout(orientation='vertical', spacing=5, padding=10)
        self.add_widget(root)
        self.top_hand_container = BoxLayout(orientation='horizontal', size_hint=(1, 0.3))
        root.add_widget(self.top_hand_container)
        middle = BoxLayout(orientation='horizontal', size_hint=(1, 0.3), spacing=20)
        root.add_widget(middle)
        self.discard_btn = Button(text='', font_size='24sp', size_hint=(0.4, 1), disabled=True)
        middle.add_widget(self.discard_btn)
        self.deck_btn = Button(text='Draw', font_size='24sp', size_hint=(0.4, 1))
        self.deck_btn.bind(on_release=self.draw_pressed)
        middle.add_widget(self.deck_btn)
        self.turn_label = Label(text='', font_size='18sp', size_hint=(0.2, 1))
        middle.add_widget(self.turn_label)
        self.bottom_hand_container = BoxLayout(orientation='horizontal', size_hint=(1, 0.4))
        root.add_widget(self.bottom_hand_container)

    def update_ui(self):
        self.top_hand_container.clear_widgets()
        if self.vs_computer:
            other_count = len(self.state['hands'][1])
            label = Label(text=f'Computer: {other_count} cards', font_size='18sp')
            self.top_hand_container.add_widget(label)
        else:
            for idx, card in enumerate(self.state['hands'][1]):
                btn = self.create_card_button(card, player_idx=1, card_index=idx)
                btn.disabled = (self.state['turn'] != 1)
                self.top_hand_container.add_widget(btn)
        self.bottom_hand_container.clear_widgets()
        for idx, card in enumerate(self.state['hands'][0]):
            btn = self.create_card_button(card, player_idx=0, card_index=idx)
            btn.disabled = (self.state['turn'] != 0)
            self.bottom_hand_container.add_widget(btn)
        top_card = self.state['discard'][-1]
        self.discard_btn.text = display_text(top_card)
        self.discard_btn.background_color = card_colour_to_rgba(top_card['colour'])
        if self.state['turn'] == 0:
            turn_text = 'Your turn'
        else:
            turn_text = 'Opponent\'s turn'
        colour_text = self.state['current_colour']
        self.turn_label.text = f'[b]{turn_text}\nCurrent colour: {colour_text}[/b]'
        self.turn_label.markup = True
        self.deck_btn.disabled = (self.state['turn'] != 0)

    def create_card_button(self, card, player_idx, card_index):
        txt = display_text(card)
        colour = card_colour_to_rgba(card['colour'])
        btn = Button(text=txt, background_color=colour, font_size='20sp')
        btn.bind(on_release=lambda inst: self.card_pressed(player_idx, card_index))
        return btn

    def card_pressed(self, player_idx, card_index):
        if self.state['turn'] != player_idx:
            return
        hand = self.state['hands'][player_idx]
        card = hand[card_index]
        if not can_play(card, self.state['current_colour'], self.state['current_value']):
            return
        hand.pop(card_index)
        if card['colour'] == 'wild':
            def choose_colour(colour):
                self.state['current_colour'] = colour
                played_card = {'colour': 'wild', 'value': card['value']}
                draw_count, offset = apply_played_card(played_card, self.state)
                self.state['current_colour'] = colour
                if draw_count > 0:
                    next_idx = next_turn_index(self.state, 1)
                    draw_multiple(self.state, next_idx, draw_count)
                advance_turn(self.state, offset)
                self.update_ui()
                popup.dismiss()
                self.check_end_or_ai()

            content = BoxLayout(orientation='vertical', spacing=5, padding=10)
            label = Label(text='Choose a colour', font_size='18sp', size_hint=(1, 0.3))
            content.add_widget(label)
            colours_row = BoxLayout(orientation='horizontal', size_hint=(1, 0.7), spacing=5)
            content.add_widget(colours_row)
            for colour_option in COLOURS:
                btn = Button(text=colour_option.capitalize(), background_color=card_colour_to_rgba(colour_option))
                btn.bind(on_release=lambda inst, col=colour_option: choose_colour(col))
                colours_row.add_widget(btn)
            popup = Popup(title='Choose colour', content=content, size_hint=(0.6, 0.6), auto_dismiss=False)
            popup.open()
        else:
            draw_count, offset = apply_played_card(card, self.state)
            if draw_count > 0:
                next_idx = next_turn_index(self.state, 1)
                draw_multiple(self.state, next_idx, draw_count)
            advance_turn(self.state, offset)
            self.update_ui()
            self.check_end_or_ai()

    def draw_pressed(self, instance):
        player_idx = 0
        if self.state['turn'] != player_idx:
            return
        playable = any(can_play(card, self.state['current_colour'], self.state['current_value']) for card in self.state['hands'][player_idx])
        if playable:
            pass
        card = draw_card(self.state, player_idx)
        self.update_ui()
        playable_after = can_play(card, self.state['current_colour'], self.state['current_value'])
        if not playable_after:
            advance_turn(self.state, 1)
            self.update_ui()
            self.check_end_or_ai()

    def check_end_or_ai(self):
        winner = check_winner(self.state)
        if winner is not None:
            msg = 'You win!' if winner == 0 else 'Opponent wins!'
            content = BoxLayout(orientation='vertical', spacing=10, padding=10)
            content.add_widget(Label(text=msg, font_size='24sp'))
            btn = Button(text='Return to menu', size_hint=(1, 0.3))
            content.add_widget(btn)
            popup = Popup(title='Game over', content=content, size_hint=(0.7, 0.7))
            btn.bind(on_release=lambda *args: self.return_to_menu(popup))
            popup.open()
            return
        if self.vs_computer and self.state['turn'] == 1:
            Clock.schedule_once(lambda dt: self.computer_move(), 1)

    def computer_move(self):
        idx = 1
        hand = self.state['hands'][idx]
        playable_cards = [(i, card) for i, card in enumerate(hand) if can_play(card, self.state['current_colour'], self.state['current_value'])]
        if playable_cards:
            card_index, card = playable_cards[0]
            hand.pop(card_index)
            if card['colour'] == 'wild':
                colour_counts = {c: 0 for c in COLOURS}
                for c in hand:
                    if c['colour'] in COLOURS:
                        colour_counts[c['colour']] += 1
                chosen_colour = max(colour_counts, key=colour_counts.get)
                draw_count, offset = apply_played_card({'colour': 'wild', 'value': card['value']}, self.state)
                self.state['current_colour'] = chosen_colour
            else:
                draw_count, offset = apply_played_card(card, self.state)
            if draw_count > 0:
                next_idx = next_turn_index(self.state, 1)
                draw_multiple(self.state, next_idx, draw_count)
            advance_turn(self.state, offset)
            self.update_ui()
            self.check_end_or_ai()
        else:
            card = draw_card(self.state, idx)
            if can_play(card, self.state['current_colour'], self.state['current_value']):
                self.state['hands'][idx].remove(card)
                if card['colour'] == 'wild':
                    colour_counts = {c: 0 for c in COLOURS}
                    for c in self.state['hands'][idx]:
                        if c['colour'] in COLOURS:
                            colour_counts[c['colour']] += 1
                    chosen_colour = max(colour_counts, key=colour_counts.get)
                    draw_count, offset = apply_played_card({'colour': 'wild', 'value': card['value']}, self.state)
                    self.state['current_colour'] = chosen_colour
                else:
                    draw_count, offset = apply_played_card(card, self.state)
                if draw_count > 0:
                    next_idx = next_turn_index(self.state, 1)
                    draw_multiple(self.state, next_idx, draw_count)
                advance_turn(self.state, offset)
            else:
                advance_turn(self.state, 1)
            self.update_ui()
            self.check_end_or_ai()

    def return_to_menu(self, popup):
        popup.dismiss()
        self.manager.remove_widget(self)
        self.manager.current = 'start'


def display_text(card):
    val = card['value']
    if val == 'draw_two':
        return '+2'
    elif val == 'wild_draw_four':
        return '+4'
    elif val == 'skip':
        return 'Skip'
    elif val == 'reverse':
        return 'Rev'
    elif val == 'wild':
        return 'Wild'
    else:
        return val


def card_colour_to_rgba(colour):
    colours = {
        'red': (1, 0.3, 0.3, 1),
        'yellow': (1, 1, 0.3, 1),
        'green': (0.3, 1, 0.3, 1),
        'blue': (0.3, 0.5, 1, 1),
        'wild': (0.2, 0.2, 0.2, 1),
    }
    return colours.get(colour, (1, 1, 1, 1))


class UnoApp(App):

    def build(self):
        sm = ScreenManager()
        sm.add_widget(StartScreen(name='start'))
        return sm


if __name__ == '__main__':
    UnoApp().run()
